using System;
using System.IO;
using System.Text;
using System.Linq;
using System.Diagnostics;
using System.Collections.Generic;
using VulnerabilityScanner.Exceptions;

namespace VulnerabilityScanner
{
    public class Scanner
    {
        private enum VulnerabilityType
        {
            JsEvilScript,
            RmRf,
            RunDll32
        }

        private record Vulnerability(VulnerabilityType Type, string KeyLine, HashSet<string> FileExtensions);
        private class ScanStatus
        {
            public int ProcessedFiles { get; set; }
            public Dictionary<Vulnerability, int> VulnerabilityCounters { get; set; }
            public int ErrorCount { get; set; }
            public TimeSpan ExecutionTime { get; set; }

            public override string ToString()
            {
                StringBuilder sb = new StringBuilder();
                sb.Append($"Processed files: {ProcessedFiles}\n");
                foreach (var KeyValue in VulnerabilityCounters)
                {
                    sb.Append($"{Enum.GetName(KeyValue.Key.Type)}: {KeyValue.Value}\n");
                }
                sb.Append($"Error count: {ErrorCount}\n");
                sb.Append($"Execution time: {ExecutionTime}");

                return sb.ToString();
            }
        }

        private List<Vulnerability> vulnerabilities;
        
        private string targetDirectory;
        private bool performedScan = false;
        private ScanStatus scanStatus;

        public string TargetDirectory { get; set; }

        public Scanner(string dir)
        {
            targetDirectory = dir;
            vulnerabilities = new List<Vulnerability>
            {
                new Vulnerability(
                    VulnerabilityType.JsEvilScript, 
                    "<script>evil_script()</script>", 
                    new HashSet<string>(){ ".js" } ),
                new Vulnerability(
                    VulnerabilityType.RmRf,
                    "rm -rf %userprofile%\\Documents",
                    new HashSet<string>()
                    ),
                new Vulnerability(
                    VulnerabilityType.RunDll32,
                    "Rundll32 sus.dll SusEntry",
                    new HashSet<string>()
                    )
            };
        }

        private void ScanFile(string file)
        {
            string fileExtension = new FileInfo(file).Extension;
            try
            {
                using var reader = new StreamReader(file);

                while (!reader.EndOfStream)
                {
                    var line = reader.ReadLine();
                    foreach (var v in vulnerabilities)
                    {
                        if (v.FileExtensions.Count != 0
                            && !v.FileExtensions.Contains(fileExtension)) continue;

                        if (line != null && line.Contains(v.KeyLine))
                        {
                            scanStatus.VulnerabilityCounters[v]++;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                scanStatus.ErrorCount++;
            }
            finally
            {
                scanStatus.ProcessedFiles++;
            }
        }

        private void ScanDirectoryAndSubDirectories(string dir)
        {
            foreach (var file in Directory.EnumerateFiles(dir))
            {
                ScanFile(file);
            }

            var subDirectories = Directory.GetDirectories(dir);
            if(subDirectories.Length > 0)
                foreach(var subDir in subDirectories)
                    ScanDirectoryAndSubDirectories(subDir);
        }
        
        public void Run()
        {
            if (!Directory.Exists(targetDirectory))
            {
                throw new DirectoryNotFoundException(targetDirectory);
            }
            
            scanStatus = new ScanStatus
            {
                VulnerabilityCounters = vulnerabilities.ToDictionary(v => v, v => 0)
            };
            
            Stopwatch timer = Stopwatch.StartNew();
            ScanDirectoryAndSubDirectories(targetDirectory);
            timer.Stop();
            scanStatus.ExecutionTime = timer.Elapsed;
            
            performedScan = true;
        }

        public string StringStatus()
        {
            if (!performedScan)
            {
                throw new StatusNotAccessibleException(targetDirectory);
            }

            StringBuilder scanStatusBuilder = new StringBuilder();
            scanStatusBuilder.Append("==== Scan result ====\n");
            scanStatusBuilder.Append(scanStatus);
            scanStatusBuilder.Append("\n================\n");

            return scanStatusBuilder.ToString();
        }
    }
}